# 樱花飘落及鼠标点击特效的实现

两类特效的实现原理高度相似，因此就放到一篇笔记中了。

## 一、效果预览

- 樱花飘落

![樱花飘落](/ScrewLake/data/notes/img/樱花飘落效果.png)

- 鼠标移动飘落星星

![飘落星星](/ScrewLake/data/notes/img/星星飘落.png)

## 二、效果实现

### 1、创建画布

以跟随鼠标移动飘落星星的特效为例：特效整体基于Canvas实现，而我们希望的是一个全屏的特效，因此我们需要创建一个全屏的画布，在画布上进行星星飘落效果的渲染

```ts
const screenWidth: number = window.screen.width
const screenHeight: number = window.screen.height

let mycanvas: HTMLCanvasElement | null = null

export function createStarCanvas() {
  mycanvas = document.createElement("canvas")
  // 这样设置只能在最一开始自适应窗口大小，无法响应式
  mycanvas.width = screenWidth
  mycanvas.height = screenHeight
  mycanvas.setAttribute("style", "position: absolute;left: 0;top: 0;pointer-events: none;z-index: 99;")
  mycanvas.setAttribute("id", "canvas_mouseMoveStar")
  document.getElementsByTagName("body")[0].appendChild(mycanvas)
  // 挂载事件监听
  window.addEventListener("mousemove", mouseMoveFunction)
}
```

- 为了特效不被遮挡，我们要将画布的层级设置的高一些
- 当画布置于较高的层级之后，为了不影响其它元素的鼠标事件，我们要禁用画布自身的鼠标事件
- 因为是鼠标移动时候触发事件，因此要挂载对鼠标移动事件的监听

### 2、绘制星星

首先我们要能绘制出五角星来，这个就不详细讲述了，有兴趣的可以去了解一下如何利用cavans绘制各种图形，直接上代码：

```ts
function createStar(ctx: CanvasRenderingContext2D, star: Star): void {
  ctx.beginPath()
  for (let i = 0; i < 5; i++) {
    //先绘制小圆上一个点
    ctx.lineTo(Math.cos(((18 + i * 72 - star.rot) * Math.PI) / 180) * star.r + star.x, -Math.sin(((18 + i * 72 - star.rot) * Math.PI) / 180) * star.r + star.y)
    //连线到大圆上一个点
    ctx.lineTo(Math.cos(((54 + i * 72 - star.rot) * Math.PI) / 180) * star.r * 3 + star.x, -Math.sin(((54 + i * 72 - star.rot) * Math.PI) / 180) * star.r * 3 + star.y)
  }
  ctx.closePath()
  ctx.fillStyle = star.color
  ctx.strokeStyle = star.color
  ctx.lineWidth = 0.1
  ctx.lineJoin = "round"
  ctx.fill()
  ctx.stroke()
}
```

成功绘制星星之后，我们还需要让星星动起来，在鼠标移动星星飘落这一事件中，每一个星星都经历了创建、移动、逐渐消失这一过程，因此我们可以创建一个Star类，在类里封装好构造、渲染、移动以及移除的方法：

```ts
const starColor = ["#ffff00", "#66fff", "#3399ff", "#99ff00", "#ff9900"]

class Star {
  // 初始坐标、角度
  x: number = 0
  y: number = 0
  rot: number = Math.random() * 90 + 90
  // 星星里面小圆半径
  r: number = Math.random() * 0.5 + 1.5
  // 运动数据
  td: number = Math.random() * 4 - 2 // 旋转
  dx: number = Math.random() * 2 - 1
  dy: number = Math.random() * 1 + 1

  // 颜色
  color: string = starColor[Math.floor(Math.random() * starColor.length)]
  // 透明度
  opacity: number = 1

  // 初始化构造方法
  init(clientX: number, clientY: number): void {
    this.x = clientX
    this.y = clientY
  }

  // 渲染
  render(ctx: CanvasRenderingContext2D): void {
    ctx.save()
    createStar(ctx, this)
    ctx.restore()
  }

  // 更新，模拟移动
  updated(): void {
    this.x += this.dx
    this.y += this.dy
    this.rot += this.td
    this.r -= 0.015
    if (this.r < 0) {
      this.remove()
    }
  }

  // 移除
  remove(): void {
    for (let i = 0; i < starList.length; i++) {
      if (starList[i] === this) {
        starList.splice(i, 1)
      }
    }
  }
}
```

- 为了更好看一些，这里星星的颜色不是完全随机生成的，而是预先选取了一些颜色，以数组的形式存储，通过生成随机数作为数组下标来在给定范围内生成不同颜色的星星
- 初始化渲染上去之后，每次更新改变星星自身的位置、状态参数即可模拟星星移动
- 每次移动后需要判断一下星星是否已经满足移除条件，满足移除条件的要及时销毁元素，避免内存溢出等问题

### 3、鼠标移动时触发星星的移动

准备好画布和星星之后，剩下的工作就是在监听到鼠标移动之后调用Star类中的方法来创建或更新星星的状态

```ts
let starList: Array<Star> = []

const mouseMoveFunction = (e: MouseEvent) => {
  let currStar = new Star()
  currStar.init(e.clientX, e.clientY)
  starList.push(currStar)

  if (!mycanvas) {
    window.removeEventListener("mousemove", mouseMoveFunction)
    createStarCanvas()
    return
  }

  let ctx = mycanvas.getContext("2d")

  for (let index = 0; index < 200; index++) {
    // 清除计时器，防止内存移除
    if (index === 0 && timeoutList.length > 0) {
      for (let timeoutName of timeoutList) {
        clearTimeout(timeoutName)
      }
    }
    // 使用setTimeout，用完就清除，防止长时间不动时候仍有计时器所带来的性能消耗以及内存占用，一定程度上避免网页卡顿
    timeoutList[index] = setTimeout(() => {
      if (ctx != null) {
        ctx.clearRect(0, 0, screenWidth, screenHeight)
        for (let star of starList) {
          // 先渲染再更新，一定是还有的
          star.render(ctx)
          star.updated()
        }
      }
    }, index * 20)
  }
}
```

### 4、最终完成

最后不要忘了，在离开页面是要销毁已经创建的画布并卸载监听事件，以防在我们不期望看到这一特效的页面中也出现（毕竟在上述实现中，监听事件是直接挂载到全局的document元素上的）

```ts
export function stopMouseMoveStar() {
  if (mycanvas) document.getElementsByTagName("body")[0].removeChild(mycanvas)
  mycanvas = null
  // 卸载事件监听
  window.removeEventListener("mousemove", mouseMoveFunction)
}
```

### 5、Vue页面中调用

```ts
import {createStarCanvas, stopMouseMoveStar} from "@/utils/mouseMoveStar.ts"

onMounted(()=>{
  createStarCanvas()
})

onBeforeUnmount(()=>{
  stopMouseMoveStar()
})
```

## 三、其它效果实现

- 整体上思路是一致的，需要修改的地方实际上只有2.2中的绘制方法，我们可以变成绘制爱心，也可以是樱花，不过类似樱花这种就不建议采用cavas直接绘制了，建议找张图片直接贴上去，例如：

```ts
let img = new Image();
// base64的樱花，太长了这里不粘贴过来了
img.src = "data:image/png;base64,....

// 在画布上
cxt.drawImage(img, 0, 0, 40 * this.s, 40 * this.s)
```

- 如果我们希望以其它方式触发：比如说点击或者自动飘落，前者只要改变监听事件即可，后者完全不需要监听，画布创建之后，直接想存储对象类的arr中放入一定数量的类实体即可（可以随机生成初始位置，在销毁元素之后自动创建一个新的这样就可以一直持续下去）
